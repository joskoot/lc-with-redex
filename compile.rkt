#lang racket
(require compiler/cm)
;(for-each
; (位 (p) (managed-compile-zo p))
; (filter
;  (位 (p)
;   (and (file-exists? p)
;    (let* ((p (path->string p)) (n (string-length p)))
;     (or
;      (and (> n 3)
;       (let ((ext (substring p (- n 3) n)))
;        (equal? ext ".rkt")))
;      (and (> n 4)
;       (let ((ext (substring p (- n 4) n)))
;        (equal? ext ".rkt")))))))
;  (directory-list)))
; 
(manager-compile-notify-handler (位 (x) (printf "notify: ~a~n" x)))
(manager-trace-handler (位 (x) (printf "trace: ~a~n" x)))
;(managed-compile-zo "all-tests.rkt")
(managed-compile-zo "test-curried-lc-grammar.rkt")
(managed-compile-zo "test-free-vars.rkt")
(managed-compile-zo "test-alpha-congruence.rkt")
(managed-compile-zo "test-curry.rkt")
(managed-compile-zo "test-beta-reductor.rkt")
(managed-compile-zo "test-beta-eta-reductor.rkt")
(managed-compile-zo "width-first-traversal.rkt")
(managed-compile-zo "test-normal-order-beta-reductor-version-1.rkt")
(managed-compile-zo "test-normal-order-beta-reductor-version-2.rkt")
(managed-compile-zo "applicative-order-y-combinator.rkt")
(managed-compile-zo "test-booleans.rkt")
(managed-compile-zo "test-pairs.rkt")
(managed-compile-zo "test-pair-numerals.rkt")
(managed-compile-zo "primes.rkt")
(managed-compile-zo "church-numerals.rkt")
(managed-compile-zo "one-point-basis.rkt")
(managed-compile-zo "term-generator.rkt")
(managed-compile-zo "test-y-derivation-in-scheme.rkt")
